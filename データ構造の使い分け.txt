1.	リストを使用する
[理由]
順次更新処理を行うとあるので、ランダムアクセスできなくても問題がありません。
また、寿命管理されるタスクとあるので、データの追加・削除を高速に行えるリストが適していると考えました。
配列の場合は要素の最大値が決まってしまうため、データ件数が分からない今回の場合には適していません。
スタック、キューの場合はイテレータなどを利用して順次アクセスできないため適しません。

2.	配列を使用する
[理由]
IDをキーとしてデータを高速に取得する、IDが符号なし整数であり、既知の範囲の連番であることから
IDを添え字として利用できると考えました。
そのため、ランダムアクセスが可能である配列が適していると考えました。
リスト、スタック、キュー、はランダムアクセスができないため適しません。
ハッシュテーブルはIDをキーとして使うことで配列に近い使い方ができますが、
今回の場合は、配列の方がパフォーマンス、メモリ効率の両方が高いです。

3.	ハッシュテーブルを使用する
[理由]
IDがランダムな値であることから、2と違い配列は適していません。
32bit符号なし整数の最大値でもアクセスできることを考慮すると、膨大なメモリ空間が必要になるためです。
ハッシュテーブルは配列ほど高速ではありませんが、IDをキーとしてデータにアクセスができます。
配列とは異なり、32bit符号なし整数の最大値でもアクセスできることを考慮しても、配列ほどのメモリ空間は必要ありません。
また、リスト、スタック、キューはランダムアクセスができず、高速にデータにアクセスできないため適していません。
以上のことから、IDをキーとして使用できるハッシュテーブルが適していると考えました。

4. キューを使用する
[理由]
登録したデータを登録した順番に取り出し、
取り出したものをコンテナからの削除にプッシュ、ポップで対応できるキューが適しています。
スタックもプッシュ、ポップができますがキューと違いFILOになるため、順番が逆になり適していません。
配列、リストでも実現できますが、FIFOでのプッシュ、ポップ操作ができるように
追加の工数が必要になるため、適していません。

5. スタックを利用する
[理由]
逆ポーランド記法で格納するとあるので、スタックの使用が適しています。
キューはFIFOであるため、逆ポーランド記法での計算には適していません。
配列、リストは4と同様に実現できますが、FILOでのプッシュ、ポップ操作ができるように
追加の工数が必要になるため、適していません。

